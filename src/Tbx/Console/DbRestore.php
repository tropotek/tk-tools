<?php
namespace Tbx\Console;

use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputOption;
use Tk\Db\Util\SqlBackup;

/**
 * @author Tropotek <info@tropotek.com>
 */
class DbRestore extends Iface
{

    protected function configure()
    {
        $this->setName('dbRestore')
            ->setAliases(array('dbr'))
            ->addArgument('filename', InputArgument::REQUIRED, 'The Database backup file (tgz) generated by tkDbBackup.')
            ->addOption('user', 'U', InputOption::VALUE_OPTIONAL, 'The database username.', 'dev')
            ->addOption('pass', 'P', InputOption::VALUE_OPTIONAL, 'The database password.', 'dev007')
            ->addOption('host', 'H', InputOption::VALUE_OPTIONAL, 'The database password.', 'localhost')
            ->addOption('type', 'M', InputOption::VALUE_OPTIONAL, 'The database type.', 'mysql')
            ->addOption('name', 'N', InputOption::VALUE_OPTIONAL, 'The database name to dump, if none then all available databases are dumped', '')
            ->setDescription('Restore Databases backed up with the tkDbBackup command');
    }


    /**
     * @throws \Exception
     */
    protected function execute(InputInterface $input, OutputInterface $output): int
    {
        $filename = $input->getArgument('filename');
        if (!is_file($filename) || \Tk\FileUtil::getExtension($filename) != 'tgz')
            throw new \Tk\Exception('This does not look like a valid tkDbBackup file!');

        $tempPath = sys_get_temp_dir().'/tk-dbRestore-'.getmyuid();
        $dirname = $tempPath . '/' . \Tk\FileUtil::removeExtension(basename($filename));    // Path to the sql files


        if ($input->getOption('name'))
            $tempPath = sys_get_temp_dir().'/'.$input->getOption('name').'-'.getmyuid();
        if (is_dir($tempPath)) {
            \Tk\FileUtil::rmdir($tempPath);
        }

        if (!is_dir($tempPath))
            mkdir($tempPath, 0777, true);

        // extract backup sql files
        $cmd = sprintf('tar zxf %s -C %s ', $filename, $tempPath);
        $this->writeComment($cmd);
        system($cmd);

        $exclude = array('Database', 'information_schema', 'performance_schema', 'phpmyadmin', 'mysql', 'dbispconfig', 'roundcube');
        // loop through all sql files and backup if table does not exist
        foreach (new \DirectoryIterator($dirname) as $fileInfo) {
            if($fileInfo->isDot()) continue;
            $dbName = \Tk\FileUtil::removeExtension($fileInfo->getFilename());
            if (in_array($dbName, $exclude)) continue;
            try {
                $this->writeComment('  Restoring ' . $dbName . ' [' . $fileInfo->getFilename() . ']:');
                $options = $input->getOptions();
                $options['name'] = $dbName;
                $db = \Tk\Db\Pdo::create($options);

                if ($db->hasDatabase($dbName)) {
                    try {
                        $db->exec('USE ' . $dbName);
                        if (count($db->getTableList()) > 0) {
                            $this->writeInfo('  Skipped. (DB Exists)');
                            continue;
                        }
                    } catch (\Exception $e) {
                        $this->writeInfo('  Skipped. (DB Connection Error)');
                    }
                } else {
                    $db->exec('CREATE DATABASE IF NOT EXISTS ' . $dbName);
                    $db->exec('USE ' . $dbName);
                    (new SqlBackup($db))->restore($fileInfo->getPathname());
                    $this->writeComment('  Restore Complete');
                }
            } catch (\Exception $e) {
                \Tk\Log::error('Error Restoring: ' . $dbName);
                \Tk\Log::error($e->__toString());
                $this->writeError('  Restore Failed');
            }
        }

        if (!$this->getConfig()->isDebug())
            \Tk\FileUtil::rmdir($tempPath);

        return Command::SUCCESS;
    }

}
